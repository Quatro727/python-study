<오류의 종류>
프로그래밍 언어에는 크게 2가지 종류의 error가 있다.

-프로그램 실행 전에 발생하는 오류->구문 오류(Syntax error)
-프로그램 실행 중에 발생하는 오류->런타임 오류(Runtime error) 또는 예외(Exception)

01.구문 오류
보통 문법을 틀리는 경우 발생하는 오류이다. 프로그램이 실행조차 되지 않는다.

02.예외
프로그램이 일단 실행된 다음에 발생하는 오류이다.
이 오류도 문법처럼 코드를 수정하면 프로그램이 정상적으로 수행된다.

<기본 예외 처리>
예외를 해결하는 것을 예외 처리라고 한다. 크게 2가지가 있다.

-조건문으로 해결
-try 구문으로 해결

이때 구문 오류는 프로그램이 실행조차 되지 않으므로 예외 처리 방법으로는 해결이 불가능하다. 오로지 문법을 수정하는 수밖에 없다.

<try except 구문>
01.기본 형식:
try:
    예외가 발생할 가능성이 있는 코드
except:
    예외가 발생했을 때의 코드
(try_except_ex1.py)

02.pass 키워드
예외가 발생하면 일단 처리해야 하지만, 해당 코드가 딱히 중요한 부분이 아니면 일단 프로그램이 강제 종료되는 것을 막자는 목적으로 
except 구문에 아무 것도 적지 않고 try 구문을 사용한다. 이때 구문 내부에 아무 것도 적지 않으면 구문 오류가 발생하므로 pass 키워드를 
적어준다.
형식:
try:
    예외가 발생할 가능성이 있는 코드
except:
    pass
(try_except_ex2.py)

<try except else 구문>
try except 구문에 else 구문을 붙여 사용하면 예외가 발생하지 않았을 때 실행할 코드를 지정할 수 있다.
기본 형식은 다음과 같다.
try:
    예외가 발생할 수 있는 코드
except:
    예외가 발생한 경우 실행할 코드
else:
    예외가 발생하지 않았을 때 실행할 코드

try->예외 가능성이 있는 코드만 try 구문에 넣음
else->예외 가능성이 없는 코드를 else 구문에 넣음. try 구문이 무사히 실행되면 else 구문이 실행됨
(try_except_else_ex1.py)

<finally 구문>
예외 처리 구문에서 가장 마지막에 사용할 수 있는 구문
예외가 발생하든 발생하지 않든 무조건 실행할 때 사용한다.
기본 형식은 아래와 같다.
try:
    예외가 발생할 수 있는 코드
except:
    예외가 발생한 경우 실행할 코드
else:
    예외가 발생하지 않았을 때 실행할 코드
finally:
    무조건 실행하는 코드
01.try, except, else, finally 구문의 조합
예외 처리 구문을 짤 때의 규칙은 다음과 같다.
-try 구문의 단독 사용 불가. 반드시 except 구문이나 finally구문과 함께 써야 한다.
-else 구문은 반드시 except 구문 뒤에 작성되야 한다.

02. finally에 대한 오해
프로그램이 항상 켜져 있는 프로그램에서 finally 구문은은
파일 처리의 예시로 들자면 파일은 반드시 마지막에 닫아야 한다.
이때 중간에 예외가 발생하면 try 구문 중간에 튕겨 버리면 파일이 제대로 닫히지 않는 사고가 발생할 수 있다.
그래서 무조건 실행되는 구문인 finally 구문으로 파일을 닫는 동작을 실행시키면 된다.
(finally_ex1.py)

03.try 구문 내부에 return 키워드를 사용하는 경우
finally 구문은 반복문 또는 함수 내부에 있을 때 그 효과가 나온다.
return 키워드를 사용해 try 구문 중간에 함수를 빠져나와도 finally 구문은 반드시 실행된다.
(finally_ex2.py)

04.반복문과 함께 사용하는 경우
finally 구문은 무조건 실행된다. 따라서 반복문에서 break로 빠져나갈 때도 마찬가지로 실행된다.
(finally_ex3.py)
코드 실행 시 break 키워드로 try 구문 전체를 빠져나가도 finally 구문이 실행됨을 알 수 있다.

<예외 객체>
예외가 발생하면 예외 정보가 생기고 해당 예외 정보 종류에 따라 예외 객체에 저장이 된다.
이러한 예외 객체에는 해당 예외의 유형, 메시지, 발생 위치 등과 같은 정보를 가지고 있다.

처음 예외 객체를 사용해보면 '예외의 종류'를 모를 수가 있다. 그럴 떄는 모든 예외를 포함하고 있는 
Exception 클래스를 사용한다.
(Excpetion_ex1.py)

<예외 구분하기>
python은 except 구문에 예외의 종류를 조건문처럼 각 예외의 종류에 따라 다르게
처리할 수 있다. 아래의 예외 처리 기본 형식을 살펴보자

try:
    예외가 발생할 가능성이 있는 구문
except 예외의 종류 A:
    예외 A가 발생했을 때 실행할 구문
except 예외 B:
    예외 B가 발생했을 때 실행할 구문
except 예외 C:
    예외 C가 발생했을 떄 실행할 구문
.....
이러한 예외의 종류에는 가장 대표적으로 2가지가 존재한다.
-ValueError: 가장 대표적으로 정수 변환 함수 int()로 
변환할 수 없는 문자열에 int()를 썼을 때 일어나는 예외
-IndexError: 리스트의 길이가 10인데 Index 넘버를 11을 지정한 경우에 발생하는 예외의 조율
(Exception_ex2.py)

<모든 예외 잡기>
except 구문으로 예외를 구분하면 if, elif, else의 조건문과 유사하게
오류를 검출하면서 확인한다.
만약 예외 조건에 부합하는 것이 존재하면 당연히 예외가 발생하고 
프로그램이 강제로 종료된다. 
(Exception_ex3.py)
위의 예시 코드를 실행하면 "예외.발생()"이라는 코드에 의해 예외가 발생한다.
이때 예외라는 이름의 변수가 없으므로 NameError에 해당되지만 예외의 종류에는 NameError가 
존재하지 않는다. 따라서 코드 실행 시 프로그램이 실행 도중에 멈춰 죽는 결과가
발생한다. 이럴 경우 모든 예외의 종류를 포함하는 Exception을 예외 처리에 포함시켜 프로그램이 
죽지 않게 하는 것이 방법이다. 아래의 예시 코드를 통해 살펴보자
(Exception_ex4.py)
코드를 실행하면 위와 같이 프로그램이 중간에 강제로 종료되지 않고 프로그램이 실행되는 것을 확인할 수 있다.
예와 처리에서 가장 중요한 것은 "이 코드에서 어떤 예외가 발생할 것인가?"를 잘 예측하는 것이다.

<raise 구문>
프로그램이 강제로 종료되는 것을 막기 위해 예외는 반드시 처리해야 된다.
하지만 프로그램을 개발하는 동안에는 여러 가지 이유로 예외를 일부러 발생시키게 하는 경우도 있다.

'아직 구현되지 않는 부분이니까 확실하게 문제가 생기게 만들자'
'이 부분을 그냥 넘어가면 나중에 큰 문제가 발생할 여지가 있으므로 강제로 종료시키자'
...
위와 같은 이유로 강제로 예외를 발생시키는 경우도 있다.

다음의 예시 코드를 보자
(raise_ex1.py)
위의 예시 코드에서 if문과 else문에 해당하는 구문을 아직 작성을 완료하지 않은 상태이다.
따라서 일부러 예외를 발생시켜 프로그램을 죽게 만들어 잊어버리지 않도록 하는 것이다.
raise 키워드라 바로 예외를 강제로 발생시키는 기능을 한다.

사용 방법은 간단하다.
raise 뒤에 예외 이름을 작성하면 된다.
이때 출력되는 메세지를 원하는 형태로 만들고 싶으면 예외 클래스를 직접 만들어야 한다.

예외 클래스를 만들어 원하는 메세지를 출력하는 방법은 클래스 파트에서 실습해보자



